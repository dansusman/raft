#!/usr/bin/env python3

import json
import random
import select
import socket
import sys
import time

time.sleep(1.5)


def get_new_elect_timeout(lower, upper):
    """Gets a random election timeout."""
    return random.uniform(lower, upper)


def get_current_time():
    """Gets the current time."""
    return time.time()


# --------------- Types of Replicas ---------------
LEAD = "leader"
CAND = "candidate"
FOLL = "follower"
# --------------- Types of Messages ---------------
RV = "req_vote"
RVR = "req_vote_response"
AE = "append_entries"
AER = "ae_response"
REDIR = "redirect"
FAIL = "fail"
OK = "ok"
GET = "get"
PUT = "put"
NOOP = "noop"
# --------------- Global Stuff ---------------
# last = 0
HEART_INTERVAL = 0.1  # frequency for sending our heartbeats, in seconds
my_id = sys.argv[1]  # this replica's ID
replica_ids = sys.argv[2:]  # The ID numbers of all the other replicas
kvstore = dict()  # store of key:value pairs ("applied")
# log of operations to apply (GET/PUT) and term
log = [{'op': None, 'term': 0}]
voted_for = None
current_term = 0
commit_index = 0
last_applied = 0
next_idx = {}  # Reinitialized after election, index of the next log entry to send
match_idx = {}  # Reinitialized after election, index of highest log entry known to be replicated
for replica in replica_ids:
    match_idx.setdefault(replica, 0)
    next_idx.setdefault(replica, 1)
heartbeat = get_current_time()
current_election_timeout = get_new_elect_timeout(0.05, 0.1)
NOLEAD = "FFFF"
leader = NOLEAD
current_role = FOLL
received_votes = set()  # votes for this replica to become leader
pending_requests = []  # buffer of client requests (messages)
# map from log entry index to follower successes for that message
replicated_entries = {}
# -------------------------------------------------
# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(my_id)

SELECT_WAIT_TIME = 0.01  # 10 milliseconds
TERMINATOR = b'}\n'
buffer = b''


def recv_msgs(sock):
    """Receive messages from the given socket."""
    global buffer

    fresh_buf = sock.recv(32768)

    # is this sock shutting down?
    if len(fresh_buf) == 0:
        return None

    buffer += fresh_buf

    msgs = []
    while TERMINATOR in buffer:
        position = buffer.find(TERMINATOR) + len(TERMINATOR)
        # -1 to remove the \n, which json.loads won't want
        msgs.append(json.loads(buffer[:position - 1].decode()))
        buffer = buffer[position:]

    return msgs


def reached_timeout(time):
    """Returns true if we have elapsed enough time to hit
    the election timeout threshold.
    """
    if current_role == LEAD:
        return False
    return time - heartbeat >= current_election_timeout


def get_last_term():
    """Returns the term of the last log entry."""
    return log[len(log) - 1]["term"]


def send_message(message):
    sock.send(json.dumps(message).encode() + b'\n')


def send_request_votes():
    """Send RequestVote RPC to each replica in the system."""
    global leader
    # term, candidateId, lastLogIndex, lastLogTerm
    mes = {
        "term": current_term,
        "candidateId": my_id,
        "lastLogIndex": len(log)-1,
        "lastLogTerm": get_last_term(),
        "src": my_id,
        "leader": leader,
        "type": RV
    }
    for replica in replica_ids:
        mes["dst"] = replica
        send_message(mes)


def log_up_to_date(idx, term):
    """Checks if candidate's log is at least as up-to-date as our log."""
    return idx >= len(log)-1 and term >= get_last_term()


def send_false_rv(msg):
    """Sends a False RequestVote RPC response."""
    mes = {
        "term": current_term,
        "voteGranted": False,
        "src": my_id,
        "dst": msg["src"],
        "leader": leader,
        "type": RVR
    }
    send_message(mes)


def receive_request_votes(msg):
    """Receive a RequestVote RPC message."""
    global heartbeat, voted_for, leader
    # reply false if term < currentTerm
    if current_role != FOLL:
        send_false_rv(msg)
    else:
        term = msg["term"]
        if term < current_term:
            send_false_rv(msg)
        elif (voted_for is None
              or voted_for == msg["candidateId"]) and \
                log_up_to_date(msg["lastLogIndex"], msg["lastLogTerm"]):
            # reset timeout
            heartbeat = get_current_time()
            voted_for = msg["candidateId"]
            mes = {
                "term": current_term,
                "voteGranted": True,
                "src": my_id,
                "dst": msg["src"],
                "leader": leader,
                "type": RVR
            }
            send_message(mes)


def send_append_entries(entries):
    """Send out AppendEntries RPCs to all replicas."""
    global heartbeat
    if current_role == LEAD:
        mes = {
            "term": current_term,
            "entries": entries,
            "leaderCommit": commit_index,
            "src": my_id,
            "leader": leader,
            "type": AE
        }
        for replica in replica_ids:
            mes["dst"] = replica
            prev_idx = next_idx[replica] - 1
            if prev_idx not in range(len(log)):
                # TODO: failing (index out of range)
                # advanced-2.json is failing pretty consistently
                # we are passing correctness on some, not all
                # failing performance on almost everything
                # need to fix PUTs because many unanswered client PUTs
                # packet storming a lot, failing tests instantly about 50% of the time
                print(prev_idx)
                print(log)
                print(len(log))
            prev_term = log[prev_idx]["term"]
            mes["prevLogIndex"] = prev_idx
            mes["prevLogTerm"] = prev_term
            send_message(mes)
        # reset timeout
        heartbeat = get_current_time()


def send_ae_response(msg, success, prevLogIdx=0, prevLogTerm=0):
    """Send a response to an AppendEntries RPC."""
    mes = {
        "term": current_term,
        "success": success,
        "src": my_id,
        "dst": msg["src"],
        "leader": leader,
        "type": AER,
        "lengthLog": len(log),
        "prevLogIdx": prevLogIdx,
        "prevLogTerm": prevLogTerm,
        "entries": msg["entries"]
    }
    send_message(mes)


def validate_log(msg):
    """Returns true if log contains an entry at prevLogIndex whose
    term matches prevLogTerm."""
    prev_idx = msg["prevLogIndex"]
    prev_term = msg["prevLogTerm"]
    return prev_idx < len(log) and log[prev_idx]["term"] == prev_term


def receive_append_entries(msg):
    """Receive an AppendEntries RPC."""
    global heartbeat, leader, current_role, log, commit_index
    prev_idx = msg["prevLogIndex"]
    prev_term = msg["prevLogTerm"]
    if current_role == CAND:
        if msg["term"] >= current_term:
            # reset timeout
            heartbeat = get_current_time()
            current_role = FOLL
            leader = msg["leader"]
        else:
            send_ae_response(msg, False, prev_idx)
    if current_role == FOLL:
        leader = msg["leader"]
        heartbeat = get_current_time()

        if prev_idx > (len(log) - 1):
            send_ae_response(msg, False, prev_idx)
        elif not validate_log(msg):
            send_ae_response(msg, False, prev_idx)
        else:
            if len(msg["entries"]) > 0:
                next_idx = prev_idx + 1
                if next_idx <= (len(log) - 1):
                    del log[next_idx:]
                log.extend(msg["entries"])
                send_ae_response(msg, True, prev_idx)
            commit_index = min((len(log) - 1), msg["leaderCommit"])


def receive_append_entries_response(msg):
    """Handle an incoming AE Response message (of type AER)."""
    global next_idx, match_idx, commit_index
    if current_role == LEAD:
        if msg["success"]:
            match_idx[msg["src"]] = msg["prevLogIdx"] + len(msg["entries"])
            next_idx[msg["src"]] = match_idx[msg["src"]] + 1
            sorted_match_idx = list(sorted(match_idx.values()))
            capital_n = sorted_match_idx[-((len(replica_ids) + 1) // 2)]
            # If there exists an N such that N > commitIndex, a majority
            # of matchIndex[i] â‰¥ N, and log[N].term == currentTerm:
            # set commitIndex = N
            if commit_index < capital_n and log[capital_n]["term"] == current_term:
                # TODO: failing index out of range ^^
                # entries = log[commit_index + 1: capital_n + 1]
                commit_index = capital_n
                apply_entries()

        else:
            next_idx[msg["src"]] = max(1, next_idx[msg['src']] - 1)
            send_append_entries(msg["entries"])

    else:
        print("Received AER at non-leader replica.")


def apply_entries():
    """Applies all committed entries."""
    global last_applied
    if commit_index > last_applied:
        apply_log(log[last_applied + 1: commit_index + 1])
        last_applied = commit_index


def apply_log(entries):
    """Adds given PUT entries to the store."""
    for entry in entries:
        if entry["term"] == current_term:
            if entry["op"] == PUT:
                handle_put(entry)


def receive_req_vote_response(msg):
    """Receive and handle a response to a RequestVote RPC."""
    global received_votes, leader, current_role, heartbeat
    if current_role == CAND:
        if msg["voteGranted"]:
            received_votes.add(msg["src"])
            if len(received_votes) > (len(replica_ids) // 2) + 1:
                print("WE HAVE A WINNER", my_id)
                leader = my_id
                current_role = LEAD
                received_votes = set()
                # reset timeout
                heartbeat = get_current_time()
                for replica in replica_ids:
                    next_idx[replica] = commit_index + 1
                    match_idx[replica] = 0
                # send out empty AppendEntries RPC heartbeats
                send_append_entries([])


def trigger_election(time):
    """Starts an election if a timeout is reached."""
    global current_term, current_role, voted_for, current_election_timeout
    if current_role != LEAD and reached_timeout(time):
        # reset state
        received_votes = set()
        current_role = CAND
        current_term += 1
        voted_for = my_id
        received_votes.add(my_id)
        if leader == NOLEAD:
            current_election_timeout = get_new_elect_timeout(0.05, 0.1)
        else:
            current_election_timeout = get_new_elect_timeout(0.3, 0.4)

        # send out "Vote for me!" messages
        send_request_votes()


def handle_put(msg):
    """Updates KVStore with new information and replies to client."""
    if msg["key"] in kvstore:
        kvstore[msg["key"]] = msg["value"]
    else:
        kvstore.setdefault(msg["key"], msg["value"])
    mes = {
        "src": my_id,
        "dst": msg["src"],
        "leader": leader,
        "type": OK,
        "MID": msg["MID"],
        "value": msg["value"]
    }
    send_message(mes)


def handle_get(msg):
    """Attempts to retrieve value from KVStore and replies to client."""
    mes = {
        "src": my_id,
        "dst": msg["src"],
        "leader": leader,
        "type": OK,
        "MID": msg["MID"],
        "value": ""
    }
    if kvstore.get(msg["key"]):
        mes["value"] = kvstore.get(msg["key"])
    send_message(mes)


def handle_get_put(msg):
    """Handle GET/PUT messages from clients."""
    if current_role == LEAD:
        if msg["type"] == PUT:
            if msg["key"] in kvstore and kvstore[msg["key"]] == msg["value"]:
                # already present in our store and no change needed
                handle_put(msg)
            else:
                entry = {
                    "op": msg["type"],
                    "term": current_term,
                    "src": msg["src"],
                    "MID": msg["MID"],
                    "key": msg["key"],
                    "value": msg["value"],
                }
                log.append(entry)
                send_append_entries([entry])
        else:
            handle_get(msg)
    else:
        mes = {
            "src": my_id,
            "dst": msg["src"],
            "leader": leader,
            "MID": msg["MID"],
            "type": REDIR
        }
        send_message(mes)


def dispatch(msg):
    """Deals with message appropriately based on type."""
    msg_type = msg["type"]
    if msg_type in [GET, PUT]:
        handle_get_put(msg)
    elif msg_type == AE:
        receive_append_entries(msg)
    elif msg_type == AER:
        receive_append_entries_response(msg)
    elif msg_type == RV:
        receive_request_votes(msg)
    elif msg_type == RVR:
        receive_req_vote_response(msg)
    elif msg_type == NOOP:
        print(f"{msg['dst']} received a NOOP from {msg['src']}")


while True:
    ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]

    curr_time = get_current_time()
    trigger_election(curr_time)
    if curr_time - heartbeat >= HEART_INTERVAL:
        send_append_entries([])

    if sock in ready:
        # if len(pending_requests) > 0:
        #     dispatch(pending_requests.pop())
        for request in pending_requests:
            dispatch(request)

        msgs = recv_msgs(sock)

        # pending_requests.extend(msgs)
        for msg in msgs:
            dispatch(msg)

    # clock = time.time()
    # if clock-last > 2:
    #     # Send a no-op message to a random peer every two seconds, just for fun
    #     # You definitely want to remove this from your implementation
    #     msg = {'src': my_id, 'dst': random.choice(
    #         replica_ids), 'leader': 'FFFF', 'type': 'noop'}

    #     # Make sure to end all messages with \n
    #     sock.send(json.dumps(msg).encode() + b'\n')

    #     print(f"{msg['src']} sending a NOOP to {msg['dst']}")
    #     last = clock
