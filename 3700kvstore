#!/usr/bin/env python3

import json
import random
import select
import socket
import sys
import time

time.sleep(1.5)


def get_new_elect_timeout(lower, upper):
    """Gets a random election timeout."""
    return random.uniform(lower, upper)


def get_current_time():
    """Gets the current time."""
    return time.time()


# --------------- Types of Replicas ---------------
LEAD = "leader"
CAND = "candidate"
FOLL = "follower"
# --------------- Types of Messages ---------------
RV = "req_vote"
RVR = "req_vote_response"
AE = "append_entries"
AER = "ae_response"
REDIR = "redirect"
FAIL = "fail"
OK = "ok"
GET = "get"
PUT = "put"
NOOP = "noop"
# --------------- Global Stuff ---------------
# last = 0
HEART_INTERVAL = 0.1  # frequency for sending our heartbeats, in seconds
my_id = sys.argv[1]  # this replica's ID
replica_ids = sys.argv[2:]  # The ID numbers of all the other replicas
kvstore = dict()  # store of key:value pairs ("applied")
# log of operations to apply (GET/PUT) and term
log = [{'op': None, 'term': 0}]
voted_for = None
current_term = 0
commit_index = 0
last_applied = 0
next_idx = {}  # Reinitialized after election, index of the next log entry to send
match_idx = {}  # Reinitialized after election, index of highest log entry known to be replicated
heartbeat = get_current_time()
current_election_timeout = get_new_elect_timeout(0.05, 0.1)
NOLEAD = "FFFF"
leader = NOLEAD
current_role = FOLL
received_votes = set()  # votes for this replica to become leader
pending_requests = []  # buffer of client requests (messages)
# map from log entry index to follower successes for that message
replicated_entries = {}
# -------------------------------------------------
# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(my_id)

SELECT_WAIT_TIME = 0.01  # 10 milliseconds
TERMINATOR = b'}\n'
buffer = b''


def recv_msgs(sock):
    """Receive messages from the given socket."""
    global buffer

    fresh_buf = sock.recv(32768)

    # is this sock shutting down?
    if len(fresh_buf) == 0:
        return None

    buffer += fresh_buf

    msgs = []
    while TERMINATOR in buffer:
        position = buffer.find(TERMINATOR) + len(TERMINATOR)
        # -1 to remove the \n, which json.loads won't want
        msgs.append(json.loads(buffer[:position - 1].decode()))
        buffer = buffer[position:]

    return msgs


def reached_timeout(time):
    """Returns true if we have elapsed enough time to hit
    the election timeout threshold.
    """
    if current_role == LEAD:
        return False
    return time - heartbeat >= current_election_timeout


def get_last_term():
    """Returns the term of the last log entry."""
    return log[len(log) - 1]["term"]


def send_message(message):
    sock.send(json.dumps(message).encode() + b'\n')


def send_request_votes():
    """Send RequestVote RPC to each replica in the system."""
    global leader
    # term, candidateId, lastLogIndex, lastLogTerm
    mes = {
        "term": current_term,
        "candidateId": my_id,
        "lastLogIndex": len(log)-1,
        "lastLogTerm": get_last_term(),
        "src": my_id,
        "leader": leader,
        "type": RV
    }
    for replica in replica_ids:
        mes["dst"] = replica
        send_message(mes)


def log_up_to_date(idx, term):
    """Checks if candidate's log is at least as up-to-date as our log."""
    return idx >= len(log)-1 and term >= get_last_term()


def send_false_rv(msg):
    """Sends a False RequestVote RPC response."""
    mes = {
        "term": current_term,
        "voteGranted": False,
        "src": my_id,
        "dst": msg["src"],
        "leader": leader,
        "type": RVR
    }
    send_message(mes)


def receive_request_votes(msg):
    """Receive a RequestVote RPC message."""
    global heartbeat, voted_for, leader
    # reply false if term < currentTerm
    if current_role != FOLL:
        send_false_rv(msg)
    else:
        term = msg["term"]
        if term < current_term:
            send_false_rv(msg)
        elif (voted_for is None
              or voted_for == msg["candidateId"]) and \
                log_up_to_date(msg["lastLogIndex"], msg["lastLogTerm"]):
            # reset timeout
            heartbeat = get_current_time()
            voted_for = msg["candidateId"]
            mes = {
                "term": current_term,
                "voteGranted": True,
                "src": my_id,
                "dst": msg["src"],
                "leader": leader,
                "type": RVR
            }
            send_message(mes)


def send_append_entries(entries):
    """Send out empty AppendEntries RPCs (heartbeat) to all replicas."""
    global heartbeat
    if current_role == LEAD:
        mes = {
            "term": current_term,
            "entries": entries,
            "leaderCommit": commit_index,
            "src": my_id,
            "leader": leader,
            "type": AE
        }
        for replica in replica_ids:
            mes["dst"] = replica
            prev_idx = next_idx[replica] - 1
            mes["prevLogIndex"] = prev_idx
            if prev_idx < len(log):
                mes["prevLogTerm"] = log[prev_idx]["term"]
            else:
                mes["prevLogTerm"] = 0
            send_message(mes)
        # reset timeout
        heartbeat = get_current_time()


def send_ae_response(msg, success):
    """Send a response to an AppendEntries RPC."""
    mes = {
        "term": current_term,
        "success": success,
        "src": my_id,
        "dst": msg["src"],
        "leader": leader,
        "type": AER,
        "lengthLog": len(log),
        "entries": msg["entries"]
    }
    send_message(mes)


def validate_log(msg):
    """Returns true if log contains an entry at prevLogIndex whose
    term matches prevLogTerm."""
    prev_idx = msg["prevLogIndex"]
    prev_term = msg["prevLogTerm"]
    return prev_idx < len(log) and log[prev_idx]["term"] == prev_term


def receive_append_entries(msg):
    """Receive an AppendEntries RPC."""
    global heartbeat, leader, current_role, log, commit_index
    # reset timeout
    heartbeat = get_current_time()
    if current_role == CAND:
        if msg["term"] >= current_term:
            current_role = FOLL
            leader = msg["leader"]
        else:
            send_ae_response(msg, False)
    if current_role == FOLL:
        leader = msg["leader"]
        heartbeat = get_current_time()
        if len(msg["entries"]) > 0:
            # this is not a heartbeat, respond to sender
            if msg["term"] < current_term or not validate_log(msg):
                send_ae_response(msg, False)
            else:
                current_i = msg["leaderCommit"] + 1
                for i in range(msg["leaderCommit"] + 1, len(log) - 1):
                    current_i = i
                    if i > len(msg["entries"]):
                        break
                    if msg["entries"][i - (msg["leaderCommit"] + 1)]["term"] != log[i]["term"]:
                        # delete existing and all that follow from current log
                        log = log[:i]
                        break
                log.extend(msg["entries"][current_i -
                           (msg["leaderCommit"] + 1):])
                if msg["leaderCommit"] > commit_index:
                    temp_comIdx = min(msg["leaderCommit"], len(log) - 1)
                    for i in range(commit_index, temp_comIdx):
                        operation = log[i]["op"]["type"]
                        print(operation)
                        # put - there already: return; not there: send AE
                        if operation == PUT:
                            # already present in our store and no change needed
                            handle_put(log[i]["op"])
                        else:
                            print(
                                "Error, AE received with incorrect type:", operation)
                    commit_index = temp_comIdx
                    send_ae_response(msg, True)


def receive_append_entries_response(msg):
    """Handle an incoming AE Response message (of type AER)."""
    global next_idx, match_idx
    if current_role == LEAD:
        if msg["success"]:
            next_idx.setdefault(msg["src"], msg["lengthLog"])
            match_idx.setdefault(msg["src"], msg["lengthLog"] - 1)
            # increase count of successes
            for entry in msg["entries"]:
                value = replicated_entries.get(entry, 0)
                replicated_entries[entry] = value + 1
                if (value + 1) > len(replica_ids) / 2:
                    apply_entry(entry)
        else:
            next_idx[msg["src"]] -= 1
            send_append_entries(msg["entries"])

    else:
        print("Received AER at non-leader replica.")


def apply_entry(entry):
    """Applies a given entry to the kvstore."""
    message = entry["op"]
    operation = message["type"]
    if operation == GET:
        handle_get(message)
    if operation == PUT:
        handle_put(message)


def receive_req_vote_response(msg):
    """Receive and handle a response to a RequestVote RPC."""
    global received_votes, leader, current_role
    if current_role == CAND:
        if msg["voteGranted"]:
            received_votes.add(msg["src"])
            if len(received_votes) > len(replica_ids) / 2:
                print("WE HAVE A WINNER", my_id)
                leader = my_id
                current_role = LEAD
                received_votes = set()
                for replica in replica_ids:
                    next_idx.setdefault(replica, len(log))
                    match_idx.setdefault(replica, 0)
                # send out empty AppendEntries RPC heartbeats
                send_append_entries([])


def trigger_election(time):
    """Starts an election if a timeout is reached."""
    global current_term, current_role, voted_for, current_election_timeout
    if current_role != LEAD and reached_timeout(time):
        # reset state
        received_votes = set()
        current_role = CAND
        current_term += 1
        voted_for = my_id
        received_votes.add(my_id)
        if leader == NOLEAD:
            current_election_timeout = get_new_elect_timeout(0.05, 0.1)
        else:
            current_election_timeout = get_new_elect_timeout(0.3, 0.4)

        # send out "Vote for me!" messages
        send_request_votes()


def handle_put(msg):
    """Updates KVStore with new information and replies to client."""
    kvstore.setdefault(msg["key"], msg["value"])
    mes = {
        "src": my_id,
        "dst": msg["src"],
        "leader": leader,
        "type": OK,
        "MID": msg["MID"],
        "value": msg["value"]
    }
    send_message(mes)


def handle_get(msg):
    """Attempts to retrieve value from KVStore and replies to client."""
    mes = {
        "src": my_id,
        "dst": msg["src"],
        "leader": leader,
        "type": OK,
        "MID": msg["MID"],
        "value": ""
    }
    if kvstore.get(msg["key"]):
        mes["value"] = kvstore.get(msg["key"])
    send_message(mes)


def handle_get_put(msg):
    """Handle GET/PUT messages from clients."""
    if current_role != LEAD:
        # fail or redirect
        if leader == NOLEAD:
            if msg not in pending_requests:
                pending_requests.append(msg)
        else:
            mes = {
                "src": my_id,
                "dst": msg["src"],
                "leader": leader,
                "MID": msg["MID"],
                "type": REDIR
            }
            send_message(mes)
    else:
        operation = msg["type"]
        # get - there already: return; not there: send empty
        if operation == GET:
            handle_get(msg)
        # put - there already: return; not there: send AE
        if operation == PUT:
            if msg["key"] in kvstore and kvstore[msg["key"]] == msg["value"]:
                # already present in our store and no change needed
                handle_put(msg)
            else:
                # add to leader log and send AE
                log.append({"op": msg, "term": current_term})
                send_append_entries(log[len(log) - 2:])


def dispatch(msg):
    """Deals with message appropriately based on type."""
    msg_type = msg["type"]
    if msg_type in [GET, PUT]:
        handle_get_put(msg)
    elif msg_type == AE:
        receive_append_entries(msg)
    elif msg_type == AER:
        receive_append_entries_response(msg)
    elif msg_type == RV:
        receive_request_votes(msg)
    elif msg_type == RVR:
        receive_req_vote_response(msg)
    elif msg_type == NOOP:
        print(f"{msg['dst']} received a NOOP from {msg['src']}")


while True:
    ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]

    curr_time = get_current_time()
    trigger_election(curr_time)
    if curr_time - heartbeat >= HEART_INTERVAL:
        send_append_entries([])

    if sock in ready:
        # if len(pending_requests) > 0:
        #     dispatch(pending_requests.pop())
        for request in pending_requests:
            dispatch(request)

        msgs = recv_msgs(sock)

        # pending_requests.extend(msgs)
        for msg in msgs:
            dispatch(msg)

    # clock = time.time()
    # if clock-last > 2:
    #     # Send a no-op message to a random peer every two seconds, just for fun
    #     # You definitely want to remove this from your implementation
    #     msg = {'src': my_id, 'dst': random.choice(
    #         replica_ids), 'leader': 'FFFF', 'type': 'noop'}

    #     # Make sure to end all messages with \n
    #     sock.send(json.dumps(msg).encode() + b'\n')

    #     print(f"{msg['src']} sending a NOOP to {msg['dst']}")
    #     last = clock
